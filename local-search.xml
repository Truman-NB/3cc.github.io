<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Speaking of HiDPI</title>
    <link href="/2024/01/20/Speaking-of-HiDPI/"/>
    <url>/2024/01/20/Speaking-of-HiDPI/</url>
    
    <content type="html"><![CDATA[<p>前天买的 type-C 转 dp 的线终于是到了，连上我刚买的 AOC 的 Q27G3XMN（2K，180Hz，miniLED 两千以内性价比还是不错），大屏看着就是爽。<br>紧接着就发现不对劲，字体怎么不细腻了，仿佛在用 Windows 一般… 进而了解到 Apple 自家的 HiDPI 技术，通过 2-3 小时的摸索，我对这技术也有了进一步的了解，记录一下。</p><h4 id="What-is-HiDPI"><a href="#What-is-HiDPI" class="headerlink" title="What is HiDPI"></a>What is HiDPI</h4><blockquote><p> HiDPI, or High Dots Per Inch, refers to displays that have a higher pixel density compared to standard displays. In other words, HiDPI displays have more pixels per inch, resulting in sharper and clearer images. This technology is particularly beneficial on smaller screens, such as those found in laptops, tablets, and smartphones, where the increased pixel density improves the visual quality and allows for crisper text and graphics.</p></blockquote><p>以上是 ChatGPT 给我的答案。顾名思义，HiDPI 指的就是相同面积上有更多的像素点，也就意味着相比于不使用这一技术的屏幕，文字会更加细腻清晰。</p><blockquote><p>HiDPI 渲染并不是由屏幕提供的，而是在操作系统中实现的，这需要计算机在输出给显示器之前就把一切文字图标等采用多倍的像素渲染成更细腻的样子。当然，这样的渲染会消耗更多的 CPU 与 GPU 运算，也就会消耗更多的能源，再加上 Retina 屏设备本身还要要承担 4 倍数量的像素显示，续航的维持必然成为一项不小的挑战。有时我们感觉苹果相继推出 Retina 屏产品只是顺应趋势的必然行为，但工程师在处理器功耗与性能的平衡取舍、屏幕材料的选择与工艺设计、电池技术的革新、操作系统的优化等等方面所付出的辛苦和努力是我们难以想象的。</p></blockquote><p>在我买的这个 AOC 显示器中，系统 Displays 选项中最高显示 HiDPI 的分辨率只有 1280×720。看起来仿佛是那个 13 英寸 macbookpro 的等比例放大，显示内容太少（这里有文章说 AppleSilicon 系列不支持 4K 以下显示器中有 HiDPI 选项，但这台 AOC 是有的）。我们知道 2K 的物理分辨率是 2560×1440，这里就是原本 1280×720 的显示效果下，通过横纵像素点各增加一倍来显示内容，并刚好契合当前显示器所支持的最大分辨率，也就是说 HiDPI 仅在硬件所支持的最大分辨率内进行放大。那按理来说，只要是小于 2K 的分辨率都可以通过 HiDPI 技术放大至 2K，比如在 1920×1080 下显示内容和比例在 27 英寸中是比较合适的，由 1920×1080 到 2560×1440，只需要横纵×1.3 不就行了嘛。但是需要注意的是 Apple 的 HiDPI 仅支持 2 倍关系。这也好理解，因为物理像素点自然是整数的，而二倍的提升效果也足矣。由于显示器的面积是固定的，HiDPI 的工作原理可以形象地理解为：在原本的物理像素点的基础上横纵增加一倍，从而细节得以增加，再面积整体等比例缩小四倍，从而重新呈现在显示器上。也就是说，1920×1080 就是这些像素点，1920×1080 （HiDPI）则有 4K 的像素点。对于 HiDPI 来说，分辨率（即 num×num）只是显示器显示内容多少的度量。</p><h4 id="How-to-make-HiDPI-available"><a href="#How-to-make-HiDPI-available" class="headerlink" title="How to make HiDPI available"></a>How to make HiDPI available</h4><p>通过前面的介绍，我们知道调节分辨率的结果不过是调节比例，限制高分辨率下的 HiDPI 就是硬件本身的最高物理分辨率（比如我不能让这个 2K 屏幕显示 4K 比例），同时也与 macbook 的渲染能力有关。于我而言，在 27 英寸下显示 1920×1080 比例的效果正合适。那怎么操作呢？联想到 HiDPI 的工作原理，我只需要让 Apple 认为我这是一块 4K 像素的显示屏不就行了。<br>网上查询可知，在 <code>/System/Library/Displays/Contents/Resources</code> 中添加一个 override 文件，形式为 plist，内容即为虚拟比例，可以在<a href="https://codeclou.github.io/Display-Override-PropertyList-File-Parser-and-Generator-with-HiDPI-Support-For-Scaled-Resolutions/%E4%B8%8A%E5%88%B6%E4%BD%9C">这个网站</a>制作。值得注意的是，由于之前提到的 SSV，Catalina 之后 <code>System</code> 文件夹为 <code>read-only</code>，可以通过外挂至 <code>/Library/Displays/Contents/Resources</code> 中同样生效。<br>嫌麻烦的可以直接使用比较新的 <a href="https://github.com/waydabber/BetterDisplay">BetterDisplay</a>，据说是 BetterDummy 的更新版，具体操作有 wiki 指导。对于我这个 AOC，就是下载软件后输入想 HiDPI-<em>fy</em> 的分辨率，即 1920×1080，apply 之后重启，在系统 Displays 选项中就可以选择了。实现原理也是在 <code>/Library</code> 中新建一个 <code>Displays</code> 文件夹进行更改。<br><img src="/images/effect.png" alt="效果"></p><hr><p>开启 1920×1080（HiDPI）后，文字变得细腻多了。但是离屏幕近点又会有颗粒感。这里不得不提到一个叫 PPI 的东西。</p><blockquote><p>因此在实际使用时，不能完全按照最佳观看距离计算结果去判断。显示器的最佳视距最多只能与胳膊长度保持一致，也就是 70 厘米左右。这与 27 英寸显示器的最佳视距基本保持一致。所以，27 英寸以下可按照先前计算结果，27 英寸以上显示器按照 107PPI 为最终结果。<br>由此，把计算结果进行修正后得到的视网膜级别屏幕 PPI 最低标准的最终结果是：<br>1080p 分辨率下，21.5 英寸的显示器最符合视网膜级别屏幕的要求。<br>2K  分辨率下，27 英寸以下的显示器符合视网膜级别屏幕的要求。<br>4K 分辨率下，屏幕尺寸在 41 英寸以下，均符合视网膜级别屏幕的要求，且尺寸越小，成像越细腻。</p></blockquote><p>这里改后 AOC 的 PPI 就是 $\frac{\sqrt{(2×1920)^2+(2×1080)^2}}{27}&#x3D;164$。如果在 1920×1080（HiDPI）和 1920×1080 模式下分别截图，需要在 PPI ≥164 的设备才能看出明显差别。</p><h4 id="References"><a href="#References" class="headerlink" title="References"></a>References</h4><ol><li><a href="https://zhuanlan.zhihu.com/p/20684620">https://zhuanlan.zhihu.com/p/20684620</a></li><li><a href="https://blog.skk.moe/post/hidpi-what-why-how/">https://blog.skk.moe/post/hidpi-what-why-how/</a></li><li><a href="https://www.jianshu.com/p/30f986617278">https://www.jianshu.com/p/30f986617278</a></li><li><a href="https://www.51cto.com/article/620457.html">https://www.51cto.com/article/620457.html</a></li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>tech</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>From iPhone7p to ...</title>
    <link href="/2024/01/20/From-iPhone7p-to/"/>
    <url>/2024/01/20/From-iPhone7p-to/</url>
    
    <content type="html"><![CDATA[<p>前几天玩弄 7p（iOS 10.2.1）的时候，发现适配版本的 app 都不能登陆，轻度使用的话，对于微信、网易云音乐来说，不能登陆也就相当于不适配。在探索登陆的方法中，却意外发现有关 iOS 逆向的知识，遂做记录。<br>以下探索都是在不越狱手机的情况下，对于这样一部老手机，总觉得越狱就让其变得不再完整。虽然直接选择越狱会省不少事… 但折腾成功的感觉也是挺舒服的。</p><h3 id="登陆微信"><a href="#登陆微信" class="headerlink" title="登陆微信"></a>登陆微信</h3><p>直接在网上查会发现大部分的教程都是越狱修改版本号 (在 info.list 中体现为 bundleshortversion 和 bundleversion，后面还会提到），在 B 站评论区看到有人说可以通过 FB 登陆。我突然想起来原来发朋友圈的时候是可以选择是否同时发布到 FaceBook 上的，如果这个方法行得通的话也未免太 easy 了。翻出古早的 fb 账号，重新设置一下密码，在新版微信添加朋友中搜索 facebookapp 把 wx 和 fb 连接一下，然后在 7p 上选择通过 facebook 登陆，跳转页面后输入 fb 账号连接即可，相当 nice。这里有一步比较关键，在手机第一次登陆微信有可能触发安全检验，账号冻结后需要扫脸解冻。但是老版本的微信不支持扫脸，这时就需要换回新版本的手机上进行解冻操作后再在老版本上重新登陆。<br>注意通过 appstore 下载适配老手机的应用，如果最新版本支持的最低系统仍满足自然可以直接下载，如果不满足则需要当前 ID 下载过这个应用，才能够自动下载适配当前系统的应用，否则会显示不适配而无法下载。我下载的这个适配 10.2.1 的微信和目前使用的 UI 基本没啥区别，由于想看一下远古微信的 UI，于是选择借助拦截软件<sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><span class="hint--top hint--rounded" aria-label="https://www.52pojie.cn/thread-1284776-1-1.html">[1]</span></a></sup>和 http 进行安装。</p><h4 id="远古版本安装"><a href="#远古版本安装" class="headerlink" title="远古版本安装"></a>远古版本安装</h4><p>首先安装拦截软件，Windows 需要关闭 virus&amp;threat protection settings 中的 real-time protection 避免系统自动识别删除。这里还需要安装12.6.5.3 版本的 iTunes<sup id="fnref:2" class="footnote-ref"><a href="#fn:2" rel="footnote"><span class="hint--top hint--rounded" aria-label="https://secure-appldnld.apple.com/itunes12/091-87819-20180912-69177170-B085-11E8-B6AB-C1D03409AD2A6/iTunes64Setup.exe">[2]</span></a></sup>，即最后一版支持 appstore 的桌面版本。<br>打开拦截软件搜索微信，找到想要拦截的版本，我这里选择的是 6.6.1，即最后支持 callKit 的版本。然后在 iTunes 中搜索微信直接下载，一般都是卡住，停止拦截，暂停下载再 resume 即可。在 library 中可以找到下载的 ipa，复制到一个文件夹待用。建议是 <code>~/Desktop/xx</code> 中比较方便。<br>编辑一个 plist 文件托管到 github 上：</p><figure class="highlight plist"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs plist"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span>?&gt;</span><br><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">plist</span> <span class="hljs-keyword">PUBLIC</span> <span class="hljs-string">&quot;-//Apple//DTD PLIST 1.0//EN&quot;</span> <span class="hljs-string">&quot;http://www.apple.com/DTDs/PropertyList-1.0.dtd&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">plist</span> <span class="hljs-attr">version</span>=<span class="hljs-string">&quot;1.0&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dict</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">key</span>&gt;</span>items<span class="hljs-tag">&lt;/<span class="hljs-name">key</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">array</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">dict</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">key</span>&gt;</span>assets<span class="hljs-tag">&lt;/<span class="hljs-name">key</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">array</span>&gt;</span><br>                    <span class="hljs-tag">&lt;<span class="hljs-name">dict</span>&gt;</span><br>                        <span class="hljs-tag">&lt;<span class="hljs-name">key</span>&gt;</span>kind<span class="hljs-tag">&lt;/<span class="hljs-name">key</span>&gt;</span><br>                        <span class="hljs-tag">&lt;<span class="hljs-name">string</span>&gt;</span>software-package<span class="hljs-tag">&lt;/<span class="hljs-name">string</span>&gt;</span><br>                        <span class="hljs-tag">&lt;<span class="hljs-name">key</span>&gt;</span>url<span class="hljs-tag">&lt;/<span class="hljs-name">key</span>&gt;</span><br>                        <span class="hljs-tag">&lt;<span class="hljs-name">string</span>&gt;</span>http://局域网ip:8000/NetEaseMusic.ipa<span class="hljs-tag">&lt;/<span class="hljs-name">string</span>&gt;</span><br>                    <span class="hljs-tag">&lt;/<span class="hljs-name">dict</span>&gt;</span><br>                <span class="hljs-tag">&lt;/<span class="hljs-name">array</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">key</span>&gt;</span>metadata<span class="hljs-tag">&lt;/<span class="hljs-name">key</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">dict</span>&gt;</span><br>                    <span class="hljs-tag">&lt;<span class="hljs-name">key</span>&gt;</span>bundle-identifier<span class="hljs-tag">&lt;/<span class="hljs-name">key</span>&gt;</span><br>                    <span class="hljs-tag">&lt;<span class="hljs-name">string</span>&gt;</span>com.netease.cloudmusic<span class="hljs-tag">&lt;/<span class="hljs-name">string</span>&gt;</span><br>                    <span class="hljs-tag">&lt;<span class="hljs-name">key</span>&gt;</span>bundle-version<span class="hljs-tag">&lt;/<span class="hljs-name">key</span>&gt;</span><br>                    <span class="hljs-tag">&lt;<span class="hljs-name">string</span>&gt;</span>3.1.1<span class="hljs-tag">&lt;/<span class="hljs-name">string</span>&gt;</span><br>                    <span class="hljs-tag">&lt;<span class="hljs-name">key</span>&gt;</span>kind<span class="hljs-tag">&lt;/<span class="hljs-name">key</span>&gt;</span><br>                    <span class="hljs-tag">&lt;<span class="hljs-name">string</span>&gt;</span>software<span class="hljs-tag">&lt;/<span class="hljs-name">string</span>&gt;</span><br>                    <span class="hljs-tag">&lt;<span class="hljs-name">key</span>&gt;</span>title<span class="hljs-tag">&lt;/<span class="hljs-name">key</span>&gt;</span><br>                    <span class="hljs-tag">&lt;<span class="hljs-name">string</span>&gt;</span>NetEaseMusic<span class="hljs-tag">&lt;/<span class="hljs-name">string</span>&gt;</span><br>                <span class="hljs-tag">&lt;/<span class="hljs-name">dict</span>&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">dict</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">array</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dict</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">plist</span>&gt;</span><br></code></pre></td></tr></table></figure><p>上面是我托管在我的 github 上的 install.plist 文件，其中 bundle-identifier 可以通过把 ipa 文件改后缀为 zip 文件进入 info.plist 查看。bundle-version 和 title 改成相应 app 的版本和名称即可。需要提醒的是，不管是 ipa 文件的名称还是后面的 title，都不能使用中文或带有空格，否则不能安装。和 plist 文件对应的，在手机浏览器上输入 <code>itms-services://?action=download-manifest&amp;url=https://raw.githubusercontent.com/troicc/ipa/main/install.plist</code> 即可安装提示安装。注意这里要托管在 github 上是因为必须是 https 类型的 url 才能引导安装，也就是通过 https 访问 plist 文件，然后 iOS 就会读取 plist 内容，下载目标局域网中的 ipa 文件。所以这种方法实际是借助 http 进行安装。在 <code>~/Desktop/xx</code> 文件夹中进入 cmd，输入 <code>python3 -m http.server 8000</code> 即可开放当前文件夹至局域网。<br>这样顺利安装 6.6.1 版本微信并通过 fb 登陆后，顺利体验到了远古 UI，怎么说呢，感觉就是 nice。想到 callKit，我猜测借助老版本微信把电话换成 googlevoice 说不定能成功，这样在新版本微信上就也能使用 callKit 了。尝试之后依旧是需要扫脸，我把微信安全团队的信息通过电脑端转发至新版微信上完成验证，然后再在老版本微信上重新换电话号码，显示成功。五分钟左右账号信息就转移至 WeChat ，在新版本微信上也确实可以使用 callKit 了。不过最近回家之后微信总是要打开转半天才能收到消息，导致处理要紧事的时候十分焦虑，相当蛋疼。</p><h3 id="登陆网易云"><a href="#登陆网易云" class="headerlink" title="登陆网易云"></a>登陆网易云</h3><p>微信老版本可以通过 fb 登陆仿佛一个还没有被程序员关闭的后门，与之相比要想登陆老版本网易云，难度可高多了。<br>我下载的是 3.1.1 版本的网易云，拦截软件显示是最早发布的一版，同样通过上述方法安装，体验下来 UI 相当简洁，也没有广告。只可惜也是登陆不了，提供的三个选项：手机号、新浪微博、网易邮箱都不行。在网上查询后只有越狱更改版本号这一个途径。但是仔细看越狱更改的步骤发现，这个方法也不过就是更改 info.list 中的 CFBundleShortVersionString 至新版本号即可。既然如此，我也能通过把 ipa 改成 zip 访问这个 info.plist 文件，更改之后再安装的效果不是一样的嘛！说干就干，一通更改后发现总是显示无法安装。我一开始还猜测是解压后 <code>iTunesMetadata.plist</code> 中的版本号也需要改成 9.0.10，不过还是失败。后来想一想，安装后系统调用的应该就是那个 neteasemusic.app 中的内容，毕竟人家越狱改的也就是这个 package 中的内容，这个 metadata 应该无关紧要。既然如此，问题出在哪呢？上网查查后发现可能存在签名被破坏的问题，突然想起来之前修改锤子便签去除审查功能时，直接安装也是失败，需要重签名才能安装。那么目标就是 find out 怎么重签名。</p><h4 id="重签名"><a href="#重签名" class="headerlink" title="重签名"></a>重签名</h4><p>首先贴出步骤，这一步我是在 macOS 上操作的：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> ~/Desktop/3<br>unzip -q test.ipa<br><span class="hljs-built_in">rm</span> -r -f Payload/neteasemusic.app/_CodeSignature<br><span class="hljs-comment">#删除原本签名</span><br>security cms -D -i developer.mobileprovision &gt; ProvisioningProfile.plist<br>/usr/libexec/PlistBuddy -x -c <span class="hljs-string">&#x27;Print Entitlements&#x27;</span> ProvisioningProfile.plist &gt; Entitlements.plist<br><span class="hljs-comment">#获取entitlements.plist待用，对整个payload进行签名</span><br><span class="hljs-built_in">cp</span> developer.mobileprovision Payload/neteasemusic.app/embedded.mobileprovision<br><span class="hljs-comment">#覆盖签名</span><br>codesign -f -s key --entitlements Entitlements.plist Payload/neteasemusic.app<br>zip -q -r NetEaseMusic.ipa Payload<br><span class="hljs-comment">#如果unzip后出现多个文件夹就空格加上</span><br>python3 -m http.server 8000<br></code></pre></td></tr></table></figure><p>这里有两个关键点，<code>developer.mobileprovision</code> 和 <code>key</code>。这也是 ipa 签名的难点，相比 apk 直接可以签名，Apple 要求个人开发者订阅年费才能签名，前者为描述文件，后者为证书，成为订阅者就可以获得。688 对于我这种小白也太贵了，折腾一下还要掏这么多钱那是必不可能。网上查查能不能免费呗 xD。原来 Apple 对于个人开发者有免费 30 天的选项，后来好像在大陆由于滥用改成 7 天。但是目前我在 apple developer 官网也<a href="https://www.jianshu.com/p/01224fc523d4">没发现</a>免费 7 天的入口，最终通过 <a href="https://www.applicationloader.net/">AppUploader</a> 使用上了免费 7 天的描述证书。<br>一开始我还安装了 <a href="https://docs.fastlane.tools/">fastlane</a> 命令行，发现也是需要证书，不如直接手动打包了。自动化打包可以看参考链接 11&amp;12。</p><h5 id="Appuploader-申请证书"><a href="#Appuploader-申请证书" class="headerlink" title="Appuploader 申请证书"></a>Appuploader 申请证书</h5><p>首先在证书管理界面创建证书，选择 Apple 开发证书即可（Apple Development），名字随便起，密码要记住，创建后下载的是 .p12 文件，点击后安装到 keychain，安装时即需要设置的密码。比较惊讶的是我之前居然已经有开发证书，忘记了咋搞的了，不过既然能申请索性都在这个平台上重新搞了。这一步就是为了得到 <code>key</code>，安装后在 terminal 输入 <code>security find-identity -v</code> 查看对应编码，即为 <code>key</code>。<br>然后在描述文件管理界面创建描述文件，名字随便起，选择 iOS 应用，证书选择刚创建的证书，设备通过连接 Mac 和 iPhone 查看其 UDID 复制粘贴上去，在哪个设备上安装就用哪个 UDID。下载下来，如果名字是 developer，就得到 <code>developer.mobileprovision</code>。<br>需要说明的是，证书的有效期是一年，而描述文件的有效期是 7 天。</p><h4 id="砸壳"><a href="#砸壳" class="headerlink" title="砸壳"></a>砸壳</h4><p>在讲述砸壳这个话题前，我实话实说是历经艰险才发现还有这一个 obstacle 的。<br>重签名后我信心满满地安装，心想这下总 OK 了吧，也不过如此。可是通过 http 总是安装不下来，由于这个过程不可视，我也难以发现到底是签名没签好、版本设置不对还是其他什么问题。怎么可视化，也就是怎么能够调试呢？在<a href="https://www.yangshebing.com/2018/01/06/iOS%E9%80%86%E5%90%91%E5%BF%85%E5%A4%87%E7%BB%9D%E6%8A%80%E4%B9%8Bipa%E9%87%8D%E7%AD%BE%E5%90%8D/">这篇博客</a>中，作者提到了一个叫 ios-deploy 命令行工具，我通过 homebrew 下载后，terminal 输入 <code>ios-deploy -d -b Payload/NetEaseMusic.app</code>，电脑就开始自动识别设备（USB 或者 WIFI）并安装。一开始结果显示 <code>The operation couldn’t be completed. Unable to launch bundleID because it has an invalid code signature, inadequate entitlements or its profile has not been explicitly trusted by the user.</code>，需要在设置里的设备管理信任证书。这就正常了，既然有证书，说明我的签名过程是没问题的。也说明 http 安装应该只适用于从 appstore 中下载的 ipa。OK，信任后再重新调试，又显示失败 process -1。啥意思嘞？我从 7p 上点开这个应用发现闪退。歪日，上网一查，原来从 appstore 下载的 ipa 都被 Apple 加上了保护壳，直接修改并重签名，安装后会出现闪退。也就是说，在这一切之前，我就需要先进行所谓的“砸壳”。其实签名的教程中许多也提到了，我没有注意到…<br>好歹算是发现问题了，那目标再一次明确，怎么砸壳。<br>搞笑的是砸壳需要一部越狱的手机，从越狱手机下载的 ipa 文件是破解了 Apple 加密的。那我的初衷就是不越狱，假如越狱的话还用得着这么折腾吗？！兜兜转转又回到原点，越狱 or not。所以说我这么折腾半天就为了登陆一个网易云实在是大材小用，一般砸壳就是为了逆分析 ipa，分析软件实现原理，更高级的那就是魔改 UI 、功能啥的，改个版本号属实是小 case 了。<br>但也不能前功尽弃吧，在淘宝上找到 5 块钱的砸一个，告诉他 3.1.1 后他先发给我一个 ipa，解压发现和我从 iTunes 下载的没啥区别，重签名安装后还是不行，他也知道不行，说是老壳子不好砸。后面他又发给我一个 ipa，我解压后发现里面已经有签名描述文件，不过已经过期 4 年了。还多了一个 MyiP14 文件，不知道是啥。但至少说明这个 ipa 不是从 appstore 下载的，他说是降级再砸壳，哥们也不懂。重签名后安装，“奇迹般”能够打开，并且！也能实现手机号正常登陆，非常 NICE！</p><hr><p>值得注意的是，这个 3.1.1 版本的网易云包内容比较简单，没有动态库，唯一的一个 plugins 文件夹我查到好像说是无法签名我就直接删掉了，也没啥影响。对于更复杂的情况，可能需要对 framework 额外签名，还可能去除时间锁等。<br><small>PS：其实不需要把 info.list 原本的 bundleID 改成个人开发者的 bundleID。</small><br>一番折腾下来，7p 可用性更高了。继了解过 apk 逆向后，对 ipa 逆向也有了全新的理解。</p><hr><p>今天又看到了一个免越狱安装未签名 ipa 的 app：trollstore 2。可惜只能安装在 iOS15，在 trollstore 中安装的 appdump 2 也只能砸壳安装好的 app。那 11p 导入老版本砸壳后更改版本号再重签名至 7p 上使用的“曲线救国”就行不通了，因为老版本是无法安装至高系统上的… 有点理解什么叫降级再砸了，降级相当于就是在低系统上越狱，用越狱的方法砸壳。</p><h3 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h3><p>iPhone 7p (10.2.1)<br>iPhone 11p（15.6）<br>MacBook Pro M1（12.6）<br>Window 10</p><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ol><li><a href="https://www.jianshu.com/p/fbc7d4c436aa">https://www.jianshu.com/p/fbc7d4c436aa</a></li><li><a href="https://www.jianshu.com/p/814e7e1906fe">https://www.jianshu.com/p/814e7e1906fe</a></li><li><a href="https://xelz.info/blog/2019/01/11/ios-code-signature/">https://xelz.info/blog/2019/01/11/ios-code-signature/</a></li><li><a href="https://blog.csdn.net/Airths/article/details/107512837">https://blog.csdn.net/Airths/article/details/107512837</a></li><li><a href="https://www.jianshu.com/p/2eac15125d00">https://www.jianshu.com/p/2eac15125d00</a></li><li><a href="http://chuquan.me/2020/03/22/ios-certificate-principle/">http://chuquan.me/2020/03/22/ios-certificate-principle/</a></li><li><a href="https://superdanny.link/2015/09/29/iOS-app-install-fail-reason/">https://superdanny.link/2015/09/29/iOS-app-install-fail-reason/</a></li><li><a href="https://www.jianshu.com/p/9b9136fa1444">https://www.jianshu.com/p/9b9136fa1444</a></li><li><a href="https://morganwang.cn/2023/07/14/ipa%E9%87%8D%E7%AD%BE%E5%90%8D/">https://morganwang.cn/2023/07/14/ipa%E9%87%8D%E7%AD%BE%E5%90%8D/</a></li><li><a href="https://www.jianshu.com/p/52deb349d5d1">https://www.jianshu.com/p/52deb349d5d1</a></li><li><a href="https://www.jianshu.com/p/4f63e8c26af8">https://www.jianshu.com/p/4f63e8c26af8</a></li><li><a href="https://juejin.cn/post/7009172244253540383">https://juejin.cn/post/7009172244253540383</a></li><li><a href="https://bbs.kanxue.com/thread-263907.htm#%E5%8F%82%E8%80%83%E6%96%87%E4%BB%B6">https://bbs.kanxue.com/thread-263907.htm#%E5%8F%82%E8%80%83%E6%96%87%E4%BB%B6</a></li></ol><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span><a href="https://www.52pojie.cn/thread-1284776-1-1.html">https://www.52pojie.cn/thread-1284776-1-1.html</a><a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:2" class="footnote-text"><span><a href="https://secure-appldnld.apple.com/itunes12/091-87819-20180912-69177170-B085-11E8-B6AB-C1D03409AD2A6/iTunes64Setup.exe">https://secure-appldnld.apple.com/itunes12/091-87819-20180912-69177170-B085-11E8-B6AB-C1D03409AD2A6/iTunes64Setup.exe</a><a href="#fnref:2" rev="footnote" class="footnote-backref"> ↩</a></span></span></li></ol></div></section>]]></content>
    
    
    
    <tags>
      
      <tag>tech</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Guitar Music Theory</title>
    <link href="/2024/01/17/Guitar-Music-Theory/"/>
    <url>/2024/01/17/Guitar-Music-Theory/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
    <tags>
      
      <tag>music</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>hexo problems</title>
    <link href="/2024/01/17/hexo-problems/"/>
    <url>/2024/01/17/hexo-problems/</url>
    
    <content type="html"><![CDATA[<p>刚发布文章时，hexo 莫名抽风。<br><code>ssh -T git@github.com</code> 显示 port22，在此之前重新替换了 ssh：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">git config --global user.name <span class="hljs-string">&quot;&quot;</span><br>git config --global user.email <span class="hljs-string">&quot;&quot;</span><br>ssh-keygen -t rsa -C <span class="hljs-string">&quot;email&quot;</span><br></code></pre></td></tr></table></figure><p>结果还是不行。在<a href="https://blog.csdn.net/wang975380547/article/details/78116070">这篇文章</a> 中按照指导在 ~&#x2F;.ssh 中增加一个 config 文件，内容为：</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">Host github.com<br><span class="hljs-keyword">User</span> <span class="hljs-title">git</span><br>Hostname ssh.github.com<br>PreferredAuthentications publickey<br>IdentityFile ~/.ssh/id_rsa<br>Port <span class="hljs-number">443</span><br></code></pre></td></tr></table></figure><p>即可。</p>]]></content>
    
    
    
    <tags>
      
      <tag>tech</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SIP and SSV of Apple</title>
    <link href="/2024/01/17/SIP-and-SSV-of-Apple/"/>
    <url>/2024/01/17/SIP-and-SSV-of-Apple/</url>
    
    <content type="html"><![CDATA[<p>最近输入法总是莫名其妙地跳 ABC，输入设置中也不能删除，查询一番后发现必须要更改 plist 文件，系统 plist 更改需要关闭电脑的 SIP，即 system integrity protection。关闭 SIP 之后我想起来之前想更改系统应用的图标时好像也需要这一操作，结果发现还是不能替换，原来苹果又搞了一个 SSV，即 signed system volume，不关闭 SSV 无法更改 read-only file system 中的内容。</p><h3 id="删除-ABC"><a href="#删除-ABC" class="headerlink" title="删除 ABC"></a>删除 ABC</h3><p>Apple silicon 系列关机后长按开机键进入 recovery system，然后在 terminal 中输入 <code>csrutil disable</code> 即可关闭 SIP。输入 <code>reboot</code> 重启。<br><strong>在 ABC 状态下</strong>，进入 <code>~/Library/Preferences/com.apple.HIToolbox.plist</code>，用 plist editor 打开，在 AppleEnabledInputSources 中找到包含 KeyboardLayout Name 为 ABC 的 item，将其删除并保存，重启即可删除 ABC。</p><h3 id="替换系统图标"><a href="#替换系统图标" class="headerlink" title="替换系统图标"></a>替换系统图标</h3><blockquote><p>Excerpt from an Apple article:<br>In macOS Catalina, Apple introduced the read-only system volume, which is a dedicated, isolated volume for system content. Now, macOS Big Sur adds strong cryptographic protections to store system content on a signed system volume (SSV). SSV features a kernel mechanism that verifies the integrity of the system content at runtime, and rejects any data — code and non-code — that doesn’t have a valid cryptographic signature from Apple.<br>SSV helps prevent tampering with any Apple software that is part of the operating system. Additionally, it makes macOS Software Update more reliable and much safer. SSV utilizes APFS snapshots, so if an update cannot be performed, the old system version can be restored without reinstallation.</p></blockquote><p>首先在 Security&amp;Privacy 中关闭 fileVault，然后同样在 recovery terminal 中，输入 <code>csrutil authenticated-root disable</code> 即可关闭 SSV，接着 <code>reboot</code>。在 terminal 中输入 <code>mount</code> 查看已挂载文件系统的列表，其中系统盘的名称，即 <code>on /</code> 前的路径，我的电脑是 <code>/dev/disk3s1s1</code>，其中 <code>dev</code> 表示 device，<code>disk3</code> 指物理磁盘，<code>s1</code> 指其上的一个分区，紧接着的 <code>s1</code> 指的是分区中的一个卷，可能包含子卷或快照，即当前设备显示内容。<br>既然原本分区中的内容不可 write，在关闭 SSV 后可以将其挂载到 writable 的分区中，然后进行改写，最后再将改写后的分区覆盖原本的快照即可。<br>具体操作如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">mkdir</span> ~/mnt<br>sudo mount -o nobrowse -t apfs /dev/disk3s1 ~/mnt<br><span class="hljs-comment">#这里就将当前系统盘挂载到当前用户的mnt文件夹中，在这一可读写区中进行目标操作即可，对于我来说就是将maps和music的图标换成复古风格</span><br>sudo bless --mount <span class="hljs-string">&quot;<span class="hljs-variable">$HOME</span>/mnt/System/Library/CoreServices/&quot;</span> --setBoot --create-snapshot<br><span class="hljs-comment">#setBoot指定挂载点作为下一次启动要使用的启动卷，并通过create-snapshot创建快照在下一次系统启动时使用</span><br></code></pre></td></tr></table></figure><p>重启后即可发现更改已经生效。不过不能再开启 SSV，否则更改将失效。这里最后一步有<a href="https://nektony.com/how-to/uninstall-default-apple-apps-on-mac">指导</a>用的是 <code>sudo bless --folder ~/mnt/System/Library/CoreServices --bootefi --create-snapsho</code>，<code>--folder</code> 也是指定挂载路径，<code>--bootefi</code> 是指定 EFI 分区的路径作为启动卷，暂时不知道区别是啥，不过指导里说可以重新 enable SIP 和 SSV。</p><blockquote><p>SSV 和文件保险箱<br>在 macOS 11 中，SSV 为系统内容提供对等的静息状态保护，因此系统宗卷不再需要加密。读取到对静息状态文件系统进行的任何修改时，文件系统会检测到这些修改。如果用户已启用文件保险箱，数据宗卷上的用户内容仍通过用户提供的密钥加密。<br>如果用户选择停用 SSV，处于静息状态的系统会变得易于篡改，此篡改可使攻击者能够在系统下次启动时提取加密的用户数据。因此，如果文件保险箱已启用，系统不会允许用户停用 SSV。<strong>静息状态保护必须同时为两个宗卷启用或停用。</strong></p></blockquote><p>值得注意的是，SSV 不能启用会导致 fileVault 也无法启用，文件不能被加密。目前来说，想要 DIY 一下就得留点风险出来，自己斟酌吧。<br>结果展示：<br><img src="/images/icons.png" alt="图标"><br>还是原来的图标有味道。</p><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://egpu.io/forums/mac-setup/macos-up-to-11/">https://egpu.io/forums/mac-setup/macos-up-to-11/</a> </p>]]></content>
    
    
    
    <tags>
      
      <tag>tech</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello world</title>
    <link href="/2024/01/12/Hello-world/"/>
    <url>/2024/01/12/Hello-world/</url>
    
    <content type="html"><![CDATA[<h4 id="建博成功"><a href="#建博成功" class="headerlink" title="建博成功"></a>建博成功</h4><p>今天终于将建立一个博客的想法付诸实践，购买域名时发现还有 cc 后缀的域名，直接从 namesilo 上买下一年，无需实名。把域名通过 CNAME 定到 github pages 上废了半天劲，才发现 deploy from a branch 要选择 master 而不是 main（config 里填的是 master）。一开始不理解 hexo 和 github pages 为啥能联系到一起，在 DNS 解析和 hexo 同步本地内容至网页的过程中，逐渐明白通过 pages 访问自己的域名可以省去买服务器的钱。果然还是要行动起来，才能了解问题，解决问题。</p>]]></content>
    
    
    
    <tags>
      
      <tag>tech</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
